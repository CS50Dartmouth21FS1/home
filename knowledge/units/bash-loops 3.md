This unit introduces you to the shell's "for loop" construct.

> I replaced my shell prompt with `$ ` for readability.

**[:arrow_forward: Video](https://dartmouth.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=3cf18f7f-30b6-49dc-89fb-acfc0166b468)**

## Loops for lists

Many commands accept a list of files on the command line and perform actions on each file in turn.
However, what if we need to perform a sequence of commands on each file in the list of files?
Some commands can only handle one file (or argument) per invocation so we need to invoke the command many times.

The shell supports a simple iteration over lists of values - typically over lists of filenames.
In the following example, we create a Markdown-format file that displays all the `png` images in the current directory.

The first command creates the file with a header line, using `$(pwd)` to ask the shell to run `pwd` and place its output into the string passed to `echo`, which then echoes it into the file.

The loop appends three lines to the file (using `>>`) for each iteration of the loop: a blank line, a subheader, and an image reference.
The variable `img` is instantiated, one at a time, with the value of each argument in the list provided after `in`, and that value is substituted wherever `$img` occurs.


```bash
$ echo "# Images in $(pwd)" > media.md
$ for img in *.png
> do
>    echo >> media.md
>    echo "## $img" >> media.md
>    echo '![]'"($img)" >> media.md
>    echo added "$img"
> done
added ssh-add-key-1.png
added ssh-add-key-2.png
added ssh-copy.png
added ssh-generation.png
$ head media.md 
# Images in /Users/dfk/Desktop/demo

## ssh-add-key-1.png
![](ssh-add-key-1.png)

## ssh-add-key-2.png
![](ssh-add-key-2.png)

## ssh-copy.png
![](ssh-copy.png)
$ 
```

The syntax `![](imagefilename)` is Markdown, but we have to escape and quote those special characters so the shell won't interpret them.
Notice that the shell *does* interpret `$img` inside double quotes, but I had to use single quotes to hide that `!`.

When rendered by a Markdown viewer, this looks great!

We may place as many commands as we want inside the body of a loop.
We can use any combination of other if/else tests and nested loops, just like in traditional languages such as C.

We are not limited to use filenames (as generated by filename globbing) in our list:

```bash
$ for house in Allen "East Wheelock" "North Park" School South West LLC
> do
>   echo $house is the best house!
> done
Allen is the best house!
East Wheelock is the best house!
North Park is the best house!
School is the best house!
South is the best house!
West is the best house!
LLC is the best house!
$ 
```

Notice the quoting.

We can use the *contents of a file* to provide the list used by `for`:

```bash
$ cat learning-fellow-emails 
Darren.Gu.22@dartmouth.edu
David.F.Kotz@dartmouth.edu
Jackson.R.McGary.23@dartmouth.edu
Jacob.M.Chen.22@dartmouth.edu
Jacob.E.Werzinsky.22@dartmouth.edu
Kelly.B.Westkaemper.22@dartmouth.edu
Rachael.E.Williams.23@dartmouth.edu
Rylee.R.Stone.21@dartmouth.edu
Wending.Wu.23@dartmouth.edu
William.P.Dinauer.23@dartmouth.edu
$ for lf in $(<learning-fellow-emails); do echo "hello $lf"; done
hello Darren.Gu.22@dartmouth.edu
hello David.F.Kotz@dartmouth.edu
hello Jackson.R.McGary.23@dartmouth.edu
hello Jacob.M.Chen.22@dartmouth.edu
hello Jacob.E.Werzinsky.22@dartmouth.edu
hello Kelly.B.Westkaemper.22@dartmouth.edu
hello Rachael.E.Williams.23@dartmouth.edu
hello Rylee.R.Stone.21@dartmouth.edu
hello Wending.Wu.23@dartmouth.edu
hello William.P.Dinauer.23@dartmouth.edu
$ 
```

The example also demonstrates how one can use semicolons to write a simple loop all on one line!
> In fact, if you type a multi-line `if` or `for` statement, then execute it, and later use up-arrow (or ctrl-P) to have the shell retrieve your earlier command, you'll see that it formats it this way.

Notice the special shell syntax `$(<filename)`, which means to substitute the contents of `filename`.
Any spaces or newlines in the file will cause the shell to delineate *words* that become arguments to `for`.

```bash
$ cat learning-fellow-names 
Darren Gu
David Kotz
Jack McGary
Jacob Chen
Jacob Werzinsky
Kelly Westkaemper
Rachael Williams
Rylee Stone
Wendell Wu
William Dinauer
$ for lf in $(<learning-fellow-names); do echo "hello $lf"; done
hello Darren
hello Gu
hello David
hello Kotz
hello Jack
hello McGary
hello Jacob
hello Chen
hello Jacob
hello Werzinsky
hello Kelly
hello Westkaemper
hello Rachael
hello Williams
hello Rylee
hello Stone
hello Wendell
hello Wu
hello William
hello Dinauer
$ 
```

Whoops!  that's not quite what we intended.
Notice that the loop was over words, not lines, from the input file.

We can even use the *output of a command* to provide the list used by `for`;
this is called "command substitution".
In this case, we're going to strip out the last names from the file using `sed`:

```bash
$ for lf in $(sed 's/ .*//' learning-fellow-names); do echo "hello $lf"; done
hello Darren
hello David
hello Jack
hello Jacob
hello Jacob
hello Kelly
hello Rachael
hello Rylee
hello Wendell
hello William
$ 
```

Let's now pull out the last names, and sort them:

```bash
$ for lf in $(sed 's/.* //' learning-fellow-names | sort); do echo "hello $lf"; done
hello Chen
hello Dinauer
hello Gu
hello Kotz
hello McGary
hello Stone
hello Werzinsky
hello Westkaemper
hello Williams
hello Wu
$ 
```

In this case, we've used a pipeline of two commands to produce the list of arguments to `for`.

## Shell substitution

To summarize, the above examples demonstrated three forms of substitution provided by the shell.
In each case, when you write a substitution expression (led by `$`) the shell subsitutes the expression for some other value.

With **variable substitution** the shell substitutes the value of a variable for the expression; a simplest example is `$foo` for a variable named `foo`.
More on variables in the next unit.

With **command substitution** the shell substitutes the expression with the output of the command mentioned in the expression.
As an example, `$(find . -name \*.c)` is replaced with the output of `find`, in this case, a list of all `.c` files found below the current directory `.` (strictly speaking, is replaced with a list of words from the output of `find`; if any filenames include spaces, the above expression may not do what you desire).

With **file substitution** the shell substitutes the expression with contents of the file mentioned in the expression.
For example, `$(<learning-fellows)` is replaced with the list of words (not lines) found in the file `learning-fellows`.